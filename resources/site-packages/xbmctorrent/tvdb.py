import requests
import re
import xml.etree.ElementTree as ET
from urlparse import urljoin
from multiprocessing.pool import ThreadPool

POOL_SIZE = 10
_pool = None
def pool():
    global _pool
    if not _pool:
        _pool = ThreadPool(POOL_SIZE)
    return _pool

BASE_URL = "http://thetvdb.com"
API_URL = "%s/api" % BASE_URL
API_KEY = "1D62F2F90030C444"
LANG = "en"


def dom2dict(node):
    ret = {}
    for child in node:
        if len(child):
            ret.setdefault(child.tag.lower(), []).append(dom2dict(child))
        else:
            ret[child.tag.lower()] = child.text
    return ret

def split_keys(meta, *keys):
    for key in keys:
        if meta.get(key):
            meta[key] = filter(None, meta[key].split("|"))
    return meta

def image_url(fragment):
    return "%s/banners/%s" % (BASE_URL, fragment)

def banner(show_id):
    return urljoin(BASE_URL, "banners/graphical/%s" % show_id)

def season_url(show_id, season):
    return "%s/banners/seasons/%s-%d-2.jpg" % (BASE_URL, show_id, season)

def update_image_urls(meta):
    if isinstance(meta, dict):
        for k, v in meta.items():
            if isinstance(v, list):
                map(update_image_urls, v)
            elif isinstance(v, dict):
                update_image_urls(v)
            elif k in ["banner", "fanart", "poster", "filename", "bannerpath", "vignettepath", "thumbnailpath"] and isinstance(v, basestring):
                meta[k] = image_url(v)
    return meta

def show_url(show_id):
    return "%s/%s/series/%s/%s.xml" % (API_URL, API_KEY, show_id, LANG)

def show_base_url(show_id):
    return "%s/%s/series/%s" % (API_URL, API_KEY, show_id)

def show_banners_url(show_id):
    return "%s/banners.xml" % (API_URL, API_KEY, show_id)

def get(show_id):
    r = requests.get(show_url(show_id))
    dom = ET.fromstring(r.content)
    if not len(dom):
        return
    meta = dom2dict(dom[0])
    meta = split_keys(meta, "actors", "genre", "writer")
    update_image_urls(meta)
    return meta

def search(name, complete=False):
    r = requests.get("http://www.thetvdb.com/api/GetSeries.php", params={
        "seriesname": re.sub("\(\w+\)", "", name).strip(),
    })
    dom = ET.fromstring(r.content)
    if not len(dom):
        return
    meta = dom2dict(dom[0])
    if not complete:
        return update_image_urls(meta)
    return get(meta["id"])

def get_banners(show_id):
    r = requests.get("%s/banners.xml" % show_base_url(show_id))
    dom = ET.fromstring(r.content)
    if not len(dom):
        return
    return update_image_urls(dom2dict(dom))["banner"]

def get_list(show_ids):
    return pool().map(get, show_ids)

def search_list(show_names, complete=False):
    #return pool().map(lambda x: search(x, complete=complete), show_names)
    return map(lambda x: search(x, complete=complete), show_names)

def get_all_meta(show_id):
    def _get_all_meta():
        r = requests.get("%s/all/%s.xml" % (show_base_url(show_id), LANG))
        dom = ET.fromstring(r.content)
        if not len(dom):
            return
        return update_image_urls(dom2dict(dom))
    meta = pool().apply_async(_get_all_meta)
    banners = pool().apply_async(get_banners, [show_id])
    meta = meta.get()
    meta["series"][0]["episodes"] = meta["episode"]
    meta = meta["series"][0]
    meta["banners"] = banners.get()
    return meta

def get_list_item(meta):
    m = lambda x: meta.get(x) or ""
    m_list = lambda x: meta.get(x) and ", ".join(meta[x]) or ""
    return {
        "label": meta["seriesname"],
        "icon": meta["poster"],
        "thumbnail": meta["poster"],
        "info": {
            "count": meta["id"],
            "title": meta["seriesname"],
            "genre": m_list("genre"),
            "plot": m("overview"),
            "plot_outline": m("overview"),
            "tagline": m("overview"),
            "rating": m("rating"),
            "code": m("imdb_id"),
            "mpaa": m("contentrating"),
            "cast": m_list("actors"),
            "castandrole": m_list("actors"),
            "tvshowtitle": meta["seriesname"],
            "status": m("status"),
            "premiered": m("firstaired"),
            "duration": m("runtime"),
            "picturepath": meta["poster"],
            "year": meta.get("firstaired") and meta["firstaired"].split("-")[0] or "",
        },
        "properties": {
            "fanart_image": m("fanart"),
        },
    }

def get_season_list_item(meta, season):
    m = lambda x: meta.get(x) or ""
    m_list = lambda x: meta.get(x) and ", ".join(meta[x]) or ""
    season_id = filter(lambda ep: int(ep["seasonnumber"]) == season, meta["episodes"])[0]["seasonid"]
    item = {
        "label": "Season %d" % season,
        "info": {
            "count": season_id,
            "tvshowtitle": meta["seriesname"],
            "season": season,
        },
        "properties": {
            "fanart_image": m("fanart"),
        },
    }
    season_banners = [banner for banner in meta["banners"] if banner["bannertype"] == "season" and int(banner["season"]) == season]
    if season_banners:
        item["icon"] = item["thumbnail"] = season_banners[0]["bannerpath"]
    return item


def build_episode_list_items(show_meta, season):
    episodes = [episode for episode in show_meta["episodes"] if int(episode["seasonnumber"]) == season]
    episodes = sorted(episodes, key=lambda ep: int(ep["episodenumber"]))
    return [{
        "label": episode.get("episodename") or "",
        "icon": episode.get("filename") or "",
        "thumbnail": episode.get("filename") or "",
        "info": {
            "count": episode.get("id"),
            "season": season,
            "episode": episode["episodenumber"],
            "title": episode.get("episodename"),
            "plot": episode.get("overview") or "",
            "plot_outline": episode.get("overview") or "",
            "tagline": episode.get("overview") or "",
            "rating": episode.get("rating") or 0,
            "code": episode.get("imdb_id") or "",
            "premiered": episode.get("firstaired") or "",
            "cast": episode.get("gueststars") and ", ".join(episode["gueststars"]) or "",
            "tvshowtitle": show_meta["seriesname"],
            "writer": episode.get("writer") and ", ".join(filter(None, episode["writer"].split("|"))) or "",
        },
        "properties": {
            "fanart_image": show_meta.get("fanart") or "",
        },
    } for episode in episodes]
