import requests
import string
import copy
import re
import random
import xbmc
import xbmcgui
from contextlib import nested, closing
from itertools import izip, groupby
from bs4 import BeautifulSoup
from multiprocessing.pool import ThreadPool

from xbmctorrent import plugin
from xbmctorrent.scrapers import scraper, ungenerate
from xbmctorrent.common import url_for_magnet
from xbmctorrent.ga import tracked
from xbmctorrent import tvdb
from xbmctorrent.utils import first, joining

# view modes:
# 502 => list
# 511 => low list
# 512 => infowall

@scraper("EZTV - Series", "http://ezimg.it/s/1/1/eztv-logo-small.png")
@plugin.route("/eztv")
@tracked
def eztv_index():
    xbmc.executebuiltin("Container.SetViewMode(514)")
    for letter in ["0-9"] + list(string.ascii_uppercase):
        yield {
            "label": letter,
            "path": plugin.url_for("eztv_shows_by_letter", letter=letter),
            "is_playable": False,
        }


@plugin.route("/eztv/shows/<letter>")
@tracked
def eztv_shows_by_letter(letter):
    plugin.set_content("tvshows")

    shows_cache = plugin.get_storage("eztv_shows") # 1 day cache
    if not len(shows_cache.keys()):
        response = requests.get("http://eztv.it/showlist/")
        soup = BeautifulSoup(response.text, "html5lib")
        nodes = soup.findAll("a", "thread_link")
        for node in nodes:
            show_id, show_named_id = node["href"].split("/")[2:4]
            show_name = node.text
            show_first_letter = show_name[0].lower()
            if re.match("\d+", show_first_letter):
                show_first_letter = "0-9"
            shows_cache.setdefault(show_first_letter, {}).update({
                show_id: {
                    "id": show_id,
                    "named_id": show_named_id,
                    "name": node.text,
                }
            })

    shows_list = sorted(shows_cache[letter.lower()].values(), key=lambda x: x["name"].lower())

    @plugin.cached()
    @ungenerate
    def _eztv_shows_by_letter(letter):
        with closing(xbmcgui.DialogProgress()) as dialog:
            dialog.create(plugin.name)

            state = {"done": 0}
            def on_serie(data):
                state["done"] += 1
                dialog.update(
                    percent=int(state["done"] * 100.0 / len(shows_list)),
                    line1="Fetching serie metadata...",
                    line2=data and data["seriesname"] or "",
                )

            with joining(ThreadPool(5)) as pool_tvdb:
                tvdb_list = [pool_tvdb.apply_async(tvdb.search, [show["name"], True], callback=on_serie) for show in shows_list]
                while not all(job.ready() for job in tvdb_list):
                    if dialog.iscanceled():
                        dialog.close()
                        return
                    xbmc.sleep(50)

        tvdb_list = [job.get() for job in tvdb_list]
        for i, (eztv_show, tvdb_show) in enumerate(izip(shows_list, tvdb_list)):
            if tvdb_show:
                item = tvdb.get_list_item(tvdb_show)
                item.update({
                    "path": plugin.url_for("eztv_get_show_seasons", show_id=eztv_show["id"], tvdb_id=tvdb_show["id"])
                })
                yield item
            else:
                yield {
                    "label": eztv_show["name"],
                    "path": plugin.url_for("eztv_get_show_seasons", show_id=eztv_show["id"])
                }
    return _eztv_shows_by_letter(letter)


def get_episode_data_from_name(name):
    res = re.search("S(\d+)E(\d+)", name)
    if res:
        return map(int, res.groups())
    res = re.search("(\d+)x(\d+)", name)
    if res:
        return map(int, res.groups())
    return -1, -1


@plugin.cached(TTL=10)
def tvdb_get_all_meta(tvdb_id):
    return tvdb.get_all_meta(tvdb_id)


@plugin.route("/eztv/shows/<show_id>/seasons")
@tracked
def eztv_get_show_seasons(show_id):
    # plugin.set_content("seasons")

    tvdb_id = first(plugin.request.args.get("tvdb_id"))
    with joining(ThreadPool(2)) as pool:
        def _eztv_get_show():
            response = requests.get("http://eztv.it/shows/%s/" % show_id)
            return BeautifulSoup(response.text, "html5lib")
        soup = pool.apply_async(_eztv_get_show)
        if tvdb_id:
            tvdb_show = pool.apply_async(tvdb_get_all_meta, [plugin.request.args["tvdb_id"][0]])

    soup = soup.get()
    fanarts = []
    if tvdb_id:
        tvdb_show = tvdb_show.get()
        fanarts = list([banner for banner in tvdb_show["banners"] if banner["bannertype"] == "fanart"])
        random.shuffle(fanarts)

    for node in soup.findAll("a", "epinfo"):
        if get_episode_data_from_name(node.text)[0] < 0:
            plugin.redirect(plugin.url_for("eztv_get_episodes_for_season", show_id=show_id, season=-1, tvdb_id=tvdb_id))
            return

    # This is needed because we need to be able to redirect if no seasons are found.
    items = []
    for i, (season, episodes) in enumerate(groupby(soup.findAll("a", "epinfo"), lambda node: get_episode_data_from_name(node.text)[0])):
        if tvdb_id:
            item = tvdb.get_season_list_item(tvdb_show, season)
        else:
            item = {
                "label": "Season %d" % season
            }
        item.update({
            "path": plugin.url_for("eztv_get_episodes_for_season", show_id=show_id, season=season, tvdb_id=tvdb_id),
        })
        if fanarts:
            item["properties"].update({
                "fanart_image": fanarts[i % len(fanarts)]["bannerpath"],
            })
        items.append(item)
    return items


@plugin.route("/eztv/shows/<show_id>/<season>/episodes")
@tracked
def eztv_get_episodes_for_season(show_id, season):
    plugin.set_content("episodes")
    season = int(season)

    tvdb_id = first(plugin.request.args.get("tvdb_id"))
    with joining(ThreadPool(2)) as pool:
        def _eztv_get_show():
            response = requests.get("http://eztv.it/shows/%s/" % show_id)
            return BeautifulSoup(response.text, "html5lib")
        soup = pool.apply_async(_eztv_get_show)
        if tvdb_id:
            tvdb_show = pool.apply_async(tvdb_get_all_meta, [plugin.request.args["tvdb_id"][0]])

    soup = soup.get()
    items = []
    fanarts = []
    if tvdb_id:
        tvdb_show = tvdb_show.get()
        fanarts = list([banner for banner in tvdb_show["banners"] if banner["bannertype"] == "fanart"])
        random.shuffle(fanarts)
        items = list(tvdb.build_episode_list_items(tvdb_show, int(season)))
    text_nodes = soup.findAll("a", "epinfo")
    href_nodes = soup.findAll("a", "magnet")
    season_nodes = izip(text_nodes, href_nodes)
    if season >= 0:
        season_nodes = filter(lambda x: ("S%02d" % season) in x[0].text, season_nodes)

    for i, (node_text, node_magnet) in enumerate(season_nodes):
        season, episode = get_episode_data_from_name(node_text.text)
        if tvdb_id and episode >= 0:
            item = copy.deepcopy(items[int(episode) - 1])
            for pattern, suffix in (("720p", "(HD)"), ("1080p", "(FullHD)"), ("repack", "(REPACK)"), ("proper", "(PROPER)")):
                if pattern in node_text.text.lower():
                    item["label"] = "%s %s" % (item["label"], suffix)
        else:
            item = {
                "label": node_text.text,
            }
        item.setdefault("info", {}).update({
            "tvshowtitle": node_text.text,
            "title": item["label"],
        })
        stream_info = {}
        if "x264" in node_text.text:
            stream_info["codec"] = item["info"]["video_codec"] = "h264"
        if "xvid" in node_text.text.lower():
            stream_info["codec"] = item["info"]["video_codec"] = "xvid"
        if "720p" in node_text.text:
            stream_info["width"] = 1280
            stream_info["height"] = 720
        if "1080p" in node_text.text:
            stream_info["width"] = 1920
            stream_info["height"] = 1080
        item.update({
            "path": url_for_magnet(node_magnet["href"]),
            "stream_info": {"video": stream_info},
            "is_playable": True,
        })
        if fanarts:
            item.setdefault("properties", {}).update({
                "fanart_image": fanarts[i % len(fanarts)]["bannerpath"],
            })
        yield item
