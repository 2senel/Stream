from xbmctorrent import plugin
import xbmc
from xbmctorrent.scrapers import scraper
from xbmctorrent.common import url_for_magnet, UA
from urlparse import urljoin
import urllib
from contextlib import closing
from BeautifulSoup import BeautifulSoup
import re
import requests

BASE_URL = "http://kickass.to"

CATEGORIES = [
    ("Audio", 100, [
        ("Music", 101),
        ("Audio Books", 102),
        ("Sound clips", 103),
        ("FLAC", 104),
        ("Other", 199),
    ]),
    ("Video", 200, [
        ("Movies", 201),
        ("Movies DVDR", 202),
        ("Music videos", 203),
        ("Movie clips", 204),
        ("TV shows", 205),
        ("Handheld", 206),
        ("HD - Movies", 207),
        ("HD - TV shows", 208),
        ("3D", 209),
        ("Other", 299),
    ]),
    ("Porn", 500, [
        ("Movies", 501),
        ("Movies DVDR", 502),
        ("HD - Movies", 503),
        ("Movie clips", 504),
        ("Other", 599),
    ]),
]


def get_url(url):
    import urllib2
    req = urllib2.Request(url)
    req.add_header('User-Agent', UA)
    with closing(urllib2.urlopen(req)) as response:
        return response.read()


def parse_tpb_page(html_data):
    soup = BeautifulSoup(html_data)
    nodes = soup.findAll("div", "detName")

    for node in nodes:
        seeds, peers = map(lambda x: x.text, node.parent.parent.findAll("td")[2:])
        magnet_node = node.parent.findAll("a")[1]
        desc_node = node.parent.findAll("font", "detDesc")[0]
        size = re.search("Size (.*?),", desc_node.text).group(1)
        text = "%s (%s S:%s P:%s)" % (node.a.text, size.replace("&nbsp;", " "), seeds, peers)
        yield {
            "label": text,
            "path": url_for_magnet(magnet_node["href"]),
            "is_playable": True,
        }


@scraper("Kickass Torrents", "http://kastatic.com/images/kickasslogosmall.png")
@plugin.route("/kickass")
def kickass_index():
    return [
        {
            "label": "Movies",
            "path": plugin.url_for("kickass_page", root="/movies", page=1)
        },
        {"label": "Search", "path": plugin.url_for("kickass_search"), "is_playable": False},
        # {"label": "Browse Torrents", "path": plugin.url_for("piratebay_browse_categories"), "is_playable": False},
    ]


@plugin.route("/kickass/browse")
def kickass_browse_categories():
    yield
    # def make_cats(root, prefix=""):
    #     for cat in root:
    #         yield {
    #             "label": "%s%s" % (prefix, cat[0]),
    #             "path": plugin.url_for("piratebay_page", root="/browse/%d" % cat[1], page=0),
    #         }
    #         if len(cat) > 2:
    #             for entry in make_cats(cat[2], prefix="%s  " % prefix):
    #                 yield entry

    # for cat in make_cats(CATEGORIES):
    #     yield cat


@plugin.route("/kickass/<root>/<page>")
def kickass_page(root, page):
    page = int(page)
    import xbmc
    response = requests.get(urljoin(BASE_URL, "%s/%d" % (root, page)))
    soup = BeautifulSoup(response.text)
    torrent_nodes = [node.parent for node in soup.findAll("td", "torrentnameCell")]

    next_page = {
        "label": "Next page...",
        "path": plugin.url_for("kickass_page", root=root, page=page + 1),
        "is_playable": False,
    }

    yield next_page
    for node in torrent_nodes:
        info_nodes = node.findAll("td")
        a_node = info_nodes[0].find("div", "torrentname").find("a", "plain")
        magnet_node = info_nodes[0].find("a", "imagnet")
        size = info_nodes[1].text
        seeds = info_nodes[4].text
        peers = info_nodes[5].text
        text = "%s (%s S:%s P:%s)" % (a_node.text, size, seeds, peers)
        yield {
            "label": text,
            "path": url_for_magnet(magnet_node["href"]),
            "is_playable": True,
        }
    yield next_page


@plugin.route("/kickass/search")
def kickass_search():
    kb = xbmc.Keyboard("", "Search")
    kb.doModal()
    if kb.isConfirmed():
        query = kb.getText()
    if query:
        for item in kickass_page(root="/usearch/%s/" % urllib.quote(query), page=0):
            yield item
