import xbmc
import xbmcgui
import requests
from contextlib import nested, closing
from xbmctorrent import plugin
from xbmctorrent.scrapers import scraper, ungenerate
from xbmctorrent.common import url_for_magnet, USER_AGENT
from xbmctorrent.ga import tracked
from xbmctorrent import tmdb
from xbmctorrent.utils import terminating
from xbmcswift2.listitem import ListItem
from itertools import izip, chain
from multiprocessing.pool import ThreadPool

BASE_URL = "https://yify-torrents.com"
YOUTUBE_ACTION = "plugin://plugin.video.youtube/?path=/root/video&action=play_video&videoid=%s"
MOVIES_PER_PAGE = 20

GENRES = [
    "Action",
    "Adventure",
    "Animation",
    "Biography",
    "Comedy",
    "Crime",
    "Documentary",
    "Drama"
    "Family",
    "Fantasy",
    "Film-Noir",
    "Game-Show",
    "History",
    "Horror",
    "Music",
    "Musical",
    "Mystery",
    "News",
    "Reality-TV",
    "Romance",
    "Sci-Fi",
    "Sport",
    "Talk-Show",
    "Thriller",
    "War",
    "Western",
]


def get(yify_id):
    return requests.get("%s/api/movie.json" % BASE_URL, params={"id": yify_id}).json()


def get_list(yify_ids, cb=None):
    f = get
    if cb:
        def _get_cb(*args, **kwargs):
            ret = get(*args, **kwargs)
            cb(ret)
            return ret
        f = _get_cb
    return pool().map(f, yify_ids)


@scraper("YIFY Torrents - Movies", "http://fbcdn-sphotos-h-a.akamaihd.net/hphotos-ak-frc3/204323_207963335901313_5804989_o.jpg")
@plugin.route("/yify")
@tracked
def yify_index():
    return [
        {"label": "Search", "path": plugin.url_for("yify_search")},
        {"label": "Browse by Genre", "path": plugin.url_for("yify_genres")},

        {"label": "Most Popular", "path": plugin.url_for("yify_show", sort="seeds", order="desc", set=1, limit=MOVIES_PER_PAGE)},
        {"label": "- in 720p", "path": plugin.url_for("yify_show", sort="seeds", order="desc", quality="720p", set=1, limit=MOVIES_PER_PAGE)},
        {"label": "- in 1080p", "path": plugin.url_for("yify_show", sort="seeds", order="desc", quality="1080p", set=1, limit=MOVIES_PER_PAGE)},
        {"label": "- in 3D", "path": plugin.url_for("yify_show", sort="seeds", order="desc", quality="3D", set=1, limit=MOVIES_PER_PAGE)},

        {"label": "Best Rated", "path": plugin.url_for("yify_show", sort="rating", order="desc", set=1, limit=MOVIES_PER_PAGE)},
        {"label": "- in 720p", "path": plugin.url_for("yify_show", sort="rating", order="desc", quality="720p", set=1, limit=MOVIES_PER_PAGE)},
        {"label": "- in 1080p", "path": plugin.url_for("yify_show", sort="rating", order="desc", quality="1080p", set=1, limit=MOVIES_PER_PAGE)},
        {"label": "- in 3D", "path": plugin.url_for("yify_show", sort="rating", order="desc", quality="3D", set=1, limit=MOVIES_PER_PAGE)},

        {"label": "Most Recent", "path": plugin.url_for("yify_show", sort="date", order="desc", set=1, limit=MOVIES_PER_PAGE)},
        {"label": "- in 720p", "path": plugin.url_for("yify_show", sort="date", order="desc", quality="720p", set=1, limit=MOVIES_PER_PAGE)},
        {"label": "- in 1080p", "path": plugin.url_for("yify_show", sort="date", order="desc", quality="1080p", set=1, limit=MOVIES_PER_PAGE)},
        {"label": "- in 3D", "path": plugin.url_for("yify_show", sort="date", order="desc", quality="3D", set=1, limit=MOVIES_PER_PAGE)},
    ]


@plugin.route("/yify/show")
@tracked
def yify_show():
    plugin.set_content("movies")
    # xbmc.executebuiltin("Container.SetViewMode(lowlist)")
    args = dict((k, v[0]) for k, v in plugin.request.args.items())

    current_page = int(args["set"])
    limit = int(args["limit"])

    with closing(xbmcgui.DialogProgress()) as dialog:
        dialog.create(plugin.name)
        dialog.update(percent=0, line1="Fetching movie information...")

        plugin.log.info(plugin.request.args)
        r = requests.get("%s/api/list.json" % BASE_URL, params=args)
        search_result = r.json()
        movies = search_result["MovieList"]

        state = {"done": 0}
        def on_movie(data):
            state["done"] += 1
            dialog.update(
                percent=int(state["done"] * 100.0 / (len(movies) * 2)),
                line2=data.get("title") or data.get("MovieTitleClean") or "",
            )

        with nested(terminating(ThreadPool(2)), terminating(ThreadPool(2))) as (pool_yify, pool_tmdb):
            yify_list = [pool_yify.apply_async(get, [movie["MovieID"]], callback=on_movie) for movie in movies]
            tmdb_list = [pool_tmdb.apply_async(tmdb.get, [movie["ImdbCode"]], callback=on_movie) for movie in movies]
            while not all(job.ready() for job in chain(yify_list, tmdb_list)):
                if dialog.iscanceled():
                    dialog.close()
                    return
                xbmc.sleep(50)

    yify_list = map(lambda job: job.get(), yify_list)
    tmdb_list = map(lambda job: job.get(), tmdb_list)

    for movie, tmdb_meta in izip(yify_list, tmdb_list):
        if tmdb_meta:
            item = tmdb.get_list_item(tmdb_meta)
            if not args.get("quality") and movie["Quality"] != "720p":
                item["label"] = "%s (%s)" % (item["label"], movie["Quality"])
            item.update({
                "path": url_for_magnet(movie["TorrentMagnetUrl"]),
                "is_playable": True,
            })
            item.setdefault("info", {}).update({
                "count": movie["MovieID"],
                "genre": "%s (%s S:%s P:%s)" % (item["info"]["genre"], movie["Size"], movie["TorrentSeeds"], movie["TorrentPeers"]),
                "trailer": YOUTUBE_ACTION % movie["YoutubeTrailerID"],
                "plot_outline": movie["ShortDescription"],
                "video_codec": "h264",
                "mpaa": movie["AgeRating"],
            })
            width, height = map(int, movie["Resolution"].split("*"))
            item.setdefault("stream_info", {}).update({
                "video": {
                    "codec": "h264",
                    "width": width,
                    "height": height,
                    "aspect": float(width) / float(height),
                },
                "audio": {
                    "language": movie["Language"],
                },
            })
            yield item

    if current_page < (int(search_result["MovieCount"]) / limit):
        next_args = args.copy()
        next_args["set"] = int(next_args["set"]) + 1
        yield {
            "label": ">> Next page",
            "path": plugin.url_for("yify_show", **next_args),
        }

@plugin.route("/yify/genres")
@tracked
def yify_genres():
    for genre in GENRES:
        yield {
            "label": genre,
            "path": plugin.url_for("yify_show", genre=genre, sort="alphabet", order="asc", set=1, limit=MOVIES_PER_PAGE),
        }

@plugin.route("/yify/search")
@tracked
def yify_search():
    query = plugin.request.args.get("query")
    if query:
        query = query[0]
    else:
        kb = xbmc.Keyboard("", "XBMCtorrent - YIFY - Search")
        kb.doModal()
        query = kb.isConfirmed() and kb.getText() or None
    if query:
        plugin.redirect(plugin.url_for("yify_show", keywords=query, set=1, limit=MOVIES_PER_PAGE))
